<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-60dp5lxFJEpUarhchGCnHw" name="test_ideas_for_statechart_and_flow_diagrams,1.0347051690476123E-305" guid="-60dp5lxFJEpUarhchGCnHw" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_state_machine__test_ideas_for&quot; name=&quot;XE_state_machine__test_ideas_for&quot;>&lt;/a>&lt;a id=&quot;XE_test_idea__for_state_machine&quot; name=&quot;XE_test_idea__for_state_machine&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introdução&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Essa diretriz mostra como identificar &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../xp/guidances/concepts/test-ideas_list_9B7EE6E1.html#TestIdeas&quot; guid=&quot;8.834380241450745E-306&quot;>ideias de teste&lt;/a> a partir de gráficos de estado e outras estruturas de design que consistem principalmente de nós ligados por arcos e que mostram algo dos possíveis fluxos de controle de um programa. O principal objetivo destes testes é percorrer todos os arcos em algum teste. Se você nunca exercitou um arco, por que acha que irá funcionar quando um cliente fizer?&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Implementation&quot; name=&quot;Implementation&quot;>Testando a Implementação&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Considere este gráfico de estado:&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;253&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img3.gif&quot; width=&quot;567&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig1: Gráfico de estado HVAC&lt;/p>&#xD;
&lt;p>Aqui está uma primeira lista de ideias de teste:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>o estado Idle recebe o evento Too Hot&lt;/li>&#xD;
    &lt;li>o estado Idle recebe o evento Too Cool&lt;/li>&#xD;
    &lt;li>o estado Cooling/Startup recebe o evento Compressor Running&lt;/li>&#xD;
    &lt;li>o estado Cooling/Ready recebe o evento Fan Running&lt;/li>&#xD;
    &lt;li>o estado Cooling/Running recebe o evento OK&lt;/li>&#xD;
    &lt;li>o estado Cooling/Running recebe o evento Failure&lt;/li>&#xD;
    &lt;li>o estado Failure recebe o evento Failure Cleared&lt;/li>&#xD;
    &lt;li>o estado Heating recebe o evento OK&lt;/li>&#xD;
    &lt;li>o estado Heating recebe o evento Failure&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Todas estas ideias de teste poderiam ser exercitadas em um único teste, ou você poderia criar vários testes onde cada um exercitaria algumas. Tal como todo design de testes, procure equilíbrio entre a facilidade de implementação de muitos testes simples e o poder adicional de busca de defeitos dos testes complexos. (veja &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../xp/guidances/concepts/test-ideas_list_9B7EE6E1.html#TestDesignUsingTheList&quot; guid=&quot;8.834380241450745E-306&quot;>&quot;design de teste usando a lista&quot;&lt;/a> na página &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../xp/guidances/concepts/test-ideas_list_9B7EE6E1.html&quot; guid=&quot;8.834380241450745E-306&quot;>Conceito: Lista de Ideias de Teste&lt;/a>). Se você tiver cenários de caso de uso que descrevam alguns caminhos no gráfico de estado, você deverá favorecer os testes que percorram esses caminhos.&lt;/p>&#xD;
&lt;p>Em todos os casos, os testes devem verificar se todas as ações exigidas pelo gráfico de estado foram efetivamente contempladas. Por exemplo, o alarme foi ativado na entrada do estado Failure e desativado após a saída?&lt;/p>&#xD;
&lt;p>O teste também deve verificar que a transição leva ao próximo estado correto. Isto pode ser um grande problema se os estados forem exteriormente invisíveis. A única forma de detectar um estado incorreto é injetar uma sequência de eventos que conduzam a uma saída incorreta. Mais precisamente, você precisa construir uma sequência contínua de eventos, cujos resultados externamente visíveis para o estado &lt;i>correto&lt;/i> difiram daqueles gerados pela mesma sequência para cada estado &lt;i>incorreto&lt;/i> possível.&lt;/p>&#xD;
&lt;p>No exemplo acima, como você sabe se o evento Failure Cleared no estado Failure direciona corretamente para o estado Idle, ao invés de ficar no estado Failure? Você poderia acreditar que a desativação do Alarme significaria que a transição aconteceu, mas poderia ser melhor verificado, baixando a temperatura o suficiente para acionar o aquecedor ou aumentando-a o suficiente para acionar a refrigeração. Se algo acontecer, você estará mais confiante de que a transição foi correta. Se nada acontecer, é provável que o dispositivo tenha ficado no estado Failure.&lt;/p>&#xD;
&lt;p>Pelo menos, determinar se o estado resultante é correto complica o design do teste. E sempre melhor tornar a máquina de estado explícita e seus estados visíveis para os testes.&lt;/p>&#xD;
&lt;h4>Outras construções de gráficos de estado&lt;/h4>&#xD;
&lt;p>Os gráficos de estado consistem mais do que arcos e flechas. Aqui está uma lista de construções de gráficos de estado e o efeito que causam na lista de ideias de teste.&lt;/p>&#xD;
&lt;h5>Ações de evento, ações de entrada e ações de saída&lt;/h5>&#xD;
&lt;p>Estes não geram ideias de teste por si só. Ao invés, os testes devem verificar que as ações comportam-se como o especificado. Se as ações representam programas substanciais, esses programas devem ser testados. As ideias de teste para os programas podem ser combinadas com as ideias de teste do gráfico de estado, mas será provavelmente muito mais gerenciável se ficarem separadas. Tome a decisão com base no esforço envolvido e em suas suspeitas de que possam existir interações entre os eventos. Ou seja, se uma determinada ação em um arco não puder compartilhar dados com uma ação em outro arco, não há nenhuma razão para exercitar as duas ações no mesmo teste (como você faria se fossem parte do mesmo caminho em um teste de gráfico de estado).&lt;/p>&#xD;
&lt;h5>Condições de guarda&lt;/h5>&#xD;
&lt;p>As condições de guarda são expressões booleanas. As ideias de teste para as condições de guarda são derivadas, como descrito em &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../xp/guidances/guidelines/test_ideas_for_booleans_and_boundaries_29731344.html&quot; guid=&quot;1.7150344523489172E-305&quot;>Diretriz: Ideias de Teste para Valores Limítrofes e Booleanos&lt;/a>.&lt;/p>&#xD;
&lt;p>No exemplo acima, a transição Too Cool do estado Idle está guardada com [restart time &amp;gt;= 5 mins]. Isto conduz a duas ideias de teste distintas:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>O estado Idle recebe o evento Too Cool quando o tempo de reinício for igual a cinco minutos (transição acontecida)&lt;/li>&#xD;
    &lt;li>O estado Idle recebe o evento Too Cool quando o tempo de reinício for um pouco menor que cinco minutos (transição bloqueada)&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Em ambos os casos, qualquer teste que use a ideia de teste deve verificar se o estado correto foi atingido.&lt;/p>&#xD;
&lt;h5>Transições internas&lt;/h5>&#xD;
&lt;p>Uma transição interna acrescenta o mesmo tipo de ideias a uma lista de ideias de teste da mesma forma que uma transição externa. Simplesmente, o próximo estado é o mesmo do estado original. Seria prudente configurar o teste de forma que as ações de entrada e saída do estado pudessem causar um efeito observável se elas fossem acionadas incorretamente.&lt;/p>&#xD;
&lt;h5>Estados aninhados&lt;/h5>&#xD;
&lt;p>Ao construir testes, configure-os de tal forma que os eventos de entrada e saída do estado composto tenham efeitos observáveis. Você precisa notar se eles forem ignorados.&lt;/p>&#xD;
&lt;h5>Sub-estados concorrentes&lt;/h5>&#xD;
&lt;p>Os testes de concorrência estão fora do escopo dos testes de desenvolvedor.&lt;/p>&#xD;
&lt;h5>Eventos adiados&lt;/h5>&#xD;
&lt;p>Se você suspeitar que um evento possa ser tratado de forma diferente, dependendo se ele foi adiado e enfileirado, em vez de gerado enquanto o programa estava realmente no estado de recepção, você poderá testar os dois casos.&lt;/p>&#xD;
&lt;p>Se o evento no estado de recepção tiver uma condição de guarda, considere as implicações das mudanças nas variáveis de condição entre o momento que o evento é gerado e o momento em que é recebido.&lt;/p>&#xD;
&lt;p>Se mais de um estado puder tratar um evento adiado, considere testar o adiamento para cada um dos estados de recepção possíveis. Talvez a implementação assuma que o estado &quot;óbvio&quot; irá tratar o evento.&lt;/p>&#xD;
&lt;h5>Estados históricos&lt;/h5>&#xD;
&lt;p>Aqui está um exemplo de um estado histórico:&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;211&quot; alt=&quot;&quot; src=&quot;resources/md_state3.gif&quot; width=&quot;412&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig2: Exemplo de Estado Histórico&lt;/p>&#xD;
&lt;p>A transição para o estado histórico representa três transições reais, e três ideias de teste:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>O evento BackingUp no estado Command conduz ao estado Collecting&lt;/li>&#xD;
    &lt;li>O evento BackingUp no estado Command conduz ao estado Copying&lt;/li>&#xD;
    &lt;li>O evento BackingUp no estado Command conduz ao estado CleaningUp&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h5>Cadeia de estados&lt;/h5>&#xD;
&lt;p>A cadeia de estados não parece ter quaisquer implicações no design de teste, exceto que ela introduz mais ações que precisam ser verificadas.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Design&quot; name=&quot;Design&quot;>Testando o Design&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>A discussão anterior focava na verificação de que a implementação correspondia ao design. Mas o design também poderá estar errado. Ao examinar o design para encontrar ideias de teste, verifique também dois tipos de problemas:&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Eventos esquecidos.&lt;/b> O gráfico de estado mostra uma resposta do estado aos eventos &lt;i>que o designer achou que poderiam chegar nesse estado&lt;/i>. Não é incomum que os designers ignorem eventos. Por exemplo, neste gráfico de estado (igual ao do topo da página), talvez o designer tenha esquecido que possa ocorrer uma falha no sub-estado Ready de Cooling, não somente quando a ventoinha estiver Running.&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;253&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img3.gif&quot; width=&quot;567&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig3: Gráfico de estados HVAC&lt;/p>&#xD;
&lt;p>Por esta razão, é sensato perguntar, para cada estado, se algum dos eventos que se aplicam a outros estados poderá ser aplicado a ele. Se você descobrir que existe algum, corrija o seu design.&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Condições de guarda incompletas ou esquecidas.&lt;/b> Do mesmo modo, talvez as condições de guarda em uma transição irão sugerir condições de guarda em outras. Por exemplo, o gráfico de estado acima toma cuidado para não reiniciar o aquecedor muitas vezes, mas não há essa restrição no sistema de refrigeração. Deveria existir?&lt;/p>&#xD;
&lt;p>Também é possível que variáveis usadas em uma condição de guarda sugiram que outras condições de guarda são muito simples.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Interactions&quot; name=&quot;Interactions&quot;>Testando Interações&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Testar cada arco em um gráfico não é uma forma de teste completo. Por exemplo, suponha que o estado de início inicialize uma variável em 0, o estado Setter a defina como 5 e o estado Divider divida 100 por ela (100/variável). Se houver um caminho do estado inicial ao Divider que não passe por Setter, você terá uma exceção de divisão por zero. Se o gráfico de estado tiver muitos estados, exercitar simplesmente cada arco poderá não considerar esse caminho.&lt;/p>&#xD;
&lt;p>Exceto para gráficos de estados muito simples, os testes de todos os caminhos é inexequível. Na prática, os testes que são complexos e que correspondem aos cenários do caso de uso são normalmente suficientes. Se você desejar testes mais fortes, considere exigir um caminho de cada estado onde um dado forneça um valor para cada estado que o usa.&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
