<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-nwZMQTZtIwI5weh9c_HoYA" name="test_ideas_for_method_calls,8.5657170364036E-306" guid="-nwZMQTZtIwI5weh9c_HoYA" changeDate="2006-11-21T20:58:59.045-0300" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_test__developer_testing__test_ideas__for_method_calls&quot; name=&quot;XE_test__developer_testing__test_ideas__for_method_calls&quot;>&lt;/a>&lt;a id=&quot;XE_design__developer_testing__test_ideas__for_method_calls&quot; name=&quot;XE_design__developer_testing__test_ideas__for_method_calls&quot;>&lt;/a>&lt;a id=&quot;XE_test-ideas__for_method_calls&quot; name=&quot;XE_test-ideas__for_method_calls&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introdução&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Veja um exemplo de código defeituoso:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
File file = new File(stringName);&#xD;
file.delete();&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>O defeito é que &lt;font size=&quot;+0&quot;>File.delete&lt;/font> pode falhar, mas o código não verifica isso. Para consertar isso é necessária a adição do código em itálico exibido abaixo:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
File file = new File(stringName);&#xD;
&lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
if (&lt;/b>&lt;/i>&lt;/font>file.delete()&lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
== false) {...}&lt;/b>&lt;/i>&lt;/font>&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Esta diretriz descreve um método para detectar os casos em que seu código não trate o resultado da chamada de um método. (Note que ela assume que o método chamado produz o resultado correto, qualquer que seja a entrada fornecida. Isso é algo que deve ser testado, mas a criação de ideias de teste para o método chamado é uma atividade separada. Ou seja, não é seu trabalho testar &lt;font size=&quot;+0&quot;>File.delete&lt;/font>.)&lt;/p>&#xD;
&lt;p>O principal conceito é que você deve criar uma ideia de teste para cada &lt;i>resultado relevante não tratado&lt;/i> de uma chamada de método. Para definir esse termo, vamos primeiro olhar para o &lt;i>resultado&lt;/i>. Quando um método é executado, ela muda o estado do mundo. Aqui estão alguns exemplos:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>Ele poderia colocar valores de retorno na pilha do interpretador.&lt;/li>&#xD;
    &lt;li>Ele poderia gerar uma exceção.&lt;/li>&#xD;
    &lt;li>Ele poderia alterar uma variável global.&lt;/li>&#xD;
    &lt;li>Ele poderia atualizar um registro em um banco de dados.&lt;/li>&#xD;
    &lt;li>Ele poderia enviar dados através da rede.&lt;/li>&#xD;
    &lt;li>Ele poderia imprimir uma mensagem na saída padrão.&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Agora vamos analisar &lt;i>relevantes&lt;/i> novamente, usando alguns exemplos.&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>Suponha que o método chamado imprima uma mensagem na saída padrão. Isso &quot;muda o estado do mundo&quot;, mas não pode afetar o processamento posterior deste programa. Independente do que foi impresso, mesmo não sendo nada, isso não pode afetar a execução do seu código.&lt;/li>&#xD;
    &lt;li>Se o método retorna verdadeiro para o sucesso e falso para o insucesso, é muito provável que o seu programa desvie com base no resultado. Então esse valor de retorno é relevante.&lt;/li>&#xD;
    &lt;li>Se o método chamado atualizar um registro em uma base de dados que o seu código irá ler e usar mais tarde, o resultado (atualizando o registro) é relevante.&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>(Não existe uma diferença clara entre relevante e irrelevante. Ao chamar &lt;font size=&quot;+0&quot;>imprimir&lt;/font>, o seu método poderia fazer com que buffers fossem alocados, e que essa alocação poderia ser relevante após o retorno de &lt;font size=&quot;+0&quot;>imprimir&lt;/font>. É possível que um defeito possa depender de se e quais buffers foram alocados. É possível, mas é sempre plausível?)&lt;/p>&#xD;
&lt;p>Um método poderá muitas vezes ter uma grande quantidade de resultados, mas apenas alguns deles serão &lt;i>distintos&lt;/i>. Por exemplo, considere um método que escreva bytes em disco. Ele pode retornar um número menor que zero para indicar falha; caso contrário, retorna a quantidade de bytes escritos (que poderá ser inferior a quantidade solicitada). A maioria das possibilidades pode ser agrupada em três resultados distintos:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>um número menor que zero.&lt;/li>&#xD;
    &lt;li>a quantidade escrita igual a quantidade solicitada&lt;/li>&#xD;
    &lt;li>alguns bytes foram escritos, mas menos do que a quantidade solicitada.&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Todos os valores menores que zero são agrupados em um único resultado porque nenhum programa razoável irá fazer distinção entre eles. Todos eles (se for possível ter mais de um) devem ser tratados como erro. De modo semelhante, se o código solicitou que 500 bytes fossem escritos, não importa se 34 ou 340 foram efetivamente escritos: a mesma coisa provavelmente será feita com os bytes não escritos. (se algo diferente tiver que ser feito para algum valor, tal como 0, isso formará um novo resultado distinto.)&lt;/p>&#xD;
&lt;p>Existe uma última palavra no termo da definição para explicar. Esta técnica especial de testes não se preocupa com os resultados diferentes que já tenham sido &lt;i>tratados&lt;/i>. Considere, novamente, esse código:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
File file = new File(stringName);&#xD;
if (file.delete() == false) {...}&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Existem dois resultados distintos (verdadeiro e falso). O código trata ambos. Ele poderia tratá-los incorretamente, mas as ideias de teste em &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../xp/guidances/guidelines/test_ideas_for_booleans_and_boundaries_29731344.html&quot; guid=&quot;1.7150344523489172E-305&quot;>Diretriz: Ideias de Teste Para Valores Limítrofes e Booleanos&lt;/a> irão verificá-los. Esta técnica de teste se preocupa com resultados distintos que não são tratados especificamente por código distinto. Isso pode acontecer por dois motivos: você pensou que a distinção era irrelevante, ou você simplesmente a ignorou. Aqui está um exemplo do primeiro caso:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
result = m.method();&#xD;
switch (result) {&#xD;
    case FAIL:&#xD;
    case CRASH:&#xD;
       ...&#xD;
       break;&#xD;
    case DEFER:&#xD;
       ...&#xD;
       break;&#xD;
    default:&#xD;
       ...&#xD;
       break;&#xD;
}&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;+0&quot;>FAIL&lt;/font> e &lt;font size=&quot;+0&quot;>CRASH&lt;/font> são tratados pelo mesmo código. É aconselhável verificar se isso é realmente adequado. Aqui está um exemplo de uma distinção ignorada:&lt;/p>&#xD;
&lt;blockquote>result = s.shutdown(); if (result == PANIC) { ... } else { // success! Desligue o reator. ... }&lt;/blockquote>&#xD;
&lt;p>Verifica-se que o método pode retornar um resultado distinto adicional: &lt;font size=&quot;+0&quot;>RETRY&lt;/font>. O código escrito trata o caso da mesma forma que no caso de sucesso, o que está quase certamente errado.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;FindingTestIdeas&quot; name=&quot;FindingTestIdeas&quot;>Encontrando ideias de teste&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Então a sua meta é pensar nesses resultados relevantes distintos que você previamente ignorou. Isso parece impossível: porque você acha que eles são relevantes agora se você não achava antes?&lt;/p>&#xD;
&lt;p>A resposta é que um re-exame sistemático do seu código, com um espírito de teste e não de programação, pode às vezes fazer-lhe ter novos pensamentos. Você &lt;i>pode&lt;/i> questionar os seus próprios pressupostos caminhando metodicamente através do seu código, olhando os métodos chamados, verificando novamente a documentação, e pensando. Aqui estão alguns casos, para verificar.&lt;/p>&#xD;
&lt;h4>Casos &quot;impossíveis&quot;&lt;/h4>&#xD;
&lt;p>Muitas vezes, parecerá que alguns retornos de erro são impossíveis. Reverifique seus pressupostos.&lt;/p>&#xD;
&lt;p>Este exemplo mostra uma implementação Java de uma expressão comum do Unix para tratamento de arquivos temporários.&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
File file = new File(&quot;tempfile&quot;);&#xD;
FileOutputStream s;&#xD;
try {&#xD;
    // open the temp file.&#xD;
    s = new FileOutputStream(file);&#xD;
} catch (IOException e) {...}&#xD;
// Make sure temp file will be deleted&#xD;
file.delete();&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>A meta é ter certeza de que um arquivo temporário é sempre excluído, independentemente da forma como o programa termina. Você faz isso criando o arquivo temporário e excluindo-o imediatamente. No Unix, você pode continuar trabalhando com o arquivo excluído, e o sistema operacional cuida da limpeza quando o processo acabar. Um programador Unix pouco meticuloso poderá deixar de escrever o código para verificar se há uma falha de exclusão. Uma vez que tenha criado o arquivo com sucesso, deverá ser capaz de apagá-lo.&lt;/p>&#xD;
&lt;p>Esse truque não funciona no Windows. A exclusão irá falhar porque o arquivo está aberto. Descobrir esse fato é difícil: até Agosto de 2000, a documentação Java não enumerava as situações onde &lt;font size=&quot;+0&quot;>excluir&lt;/font> poderia falhar, mas apenas dizia que poderia. Porém-Entretanto-Todavia no &quot;Modo de teste&quot;, o programador pode questionar seus pressupostos. Uma vez que se supõe que seu código será &quot;escrito uma vez, e executado em qualquer lugar&quot;, ele poderia perguntar a um programador, quando &lt;font     size=&quot;+0&quot;>File.delete&lt;/font> falharia no Windows e assim descobrir a terrível verdade.&lt;/p>&#xD;
&lt;h4>Casos &quot;irrelevantes&quot;&lt;/h4>&#xD;
&lt;p>Outra força contra a percepção de um valor relevante distinto, é já estar convencido que isso não importa. Um método &lt;font size=&quot;+0&quot;>comparar&lt;/font> de um &lt;font size=&quot;+0&quot;>Comparador&lt;/font> Java retorna um número menor que 0, 0 ou maior que 0. Esses são os três casos distintos que podem ser tentados. Este código coloca dois deles juntos:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
void allCheck(Comparator c) {&#xD;
   ...&#xD;
   if (c.compare(o1, o2) &amp;lt;= 0) {&#xD;
      ...&#xD;
   } else {&#xD;
      ...&#xD;
   } &#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Mas pode estar errado. A forma de descobrir se é ou não é tentar os dois casos em separado, mesmo se você realmente acreditar que não irão fazer nenhuma diferença. (O que você está realmente testando são as suas crenças). Note que você pode estar executando o ramo &lt;font size=&quot;+0&quot;>then&lt;/font> da declaração &lt;font size=&quot;+0&quot;>if&lt;/font> mais de uma vez por outras razões. Porque não experimentar um deles com o resultado inferior a 0 e outro com o resultado exatamente igual a zero?&lt;/p>&#xD;
&lt;h4>Exceções não capturadas&lt;/h4>&#xD;
&lt;p>As exceções são um tipo de resultado distinto. A título de exemplo, considere este código:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
void process(Reader r) {&#xD;
   ...&#xD;
   try {&#xD;
      ...&#xD;
      int c = r.read();&#xD;
      ...&#xD;
   } catch (IOException e) {&#xD;
      ...&#xD;
   }&#xD;
}&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Você poderia verificar se o código de tratamento realmente faz a coisa certa com uma falha de leitura. Mas suponha que uma exceção seja explicitamente não tratada. Ao invés disso, é permitida a propagação, para cima, através do código sob teste. Em Java, poderia ser semelhante a este:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
void process(Reader r) &lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
throws IOException&lt;/b>&lt;/i>&lt;/font> {&#xD;
    ...&#xD;
    int c = r.read();&#xD;
    ...&#xD;
}&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Esta técnica lhe pede para testar esse caso &lt;i>mesmo que&lt;/i> o código não trate ele explicitamente. Por quê? Devido a este tipo de falha:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
void process(Reader r) throws IOException {&#xD;
    ...&#xD;
    &lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
Tracker.hold(this);&lt;/b>&lt;/i>&lt;/font>&#xD;
    ...&#xD;
    int c = r.read();&#xD;
    ...&#xD;
    &lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
Tracker.release(this);&lt;/b>&lt;/i>&lt;/font>&#xD;
    ...&#xD;
}&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Aqui, o código afeta o estado global (through &lt;font size=&quot;+0&quot;>tracker.hold&lt;/font>). Se a exceção acontecer, &lt;font     size=&quot;+0&quot;>tracker.release&lt;/font> nunca será chamado.&lt;/p>&#xD;
&lt;p>(Note que a falha para liberar provavelmente não terá consequências óbvias imediatas. Provavelmente o problema não será visível até que &lt;font size=&quot;+0&quot;>process&lt;/font> seja chamado novamente, sendo que a tentativa de &lt;font     size=&quot;+0&quot;>manter&lt;/font> o objeto uma segunda vez irá falhar. Um bom artigo sobre esses defeitos é &lt;a href=&quot;http://www.testingcraft.com/stobie-exceptions.pdf&quot; target=&quot;_blank&quot;>&quot;Testando Exceções&quot;&lt;/a> de Keith Stobie. (&lt;a href=&quot;http://www.adobe.com/products/acrobat/alternate.html&quot; target=&quot;_blank&quot;>Get Adobe Reader&lt;/a>))&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UndiscoveredFaults&quot; name=&quot;UndiscoveredFaults&quot;>Falhas desconhecidas&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Esta técnica em particular não trata todos os defeitos associados com chamadas de métodos. Aqui estão dois tipos pouco prováveis de captura.&lt;/p>&#xD;
&lt;h4>Argumentos incorretos&lt;/h4>&#xD;
&lt;p>Considere estas duas linhas de código C, onde a primeira está errada e a segunda correta.&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
... strncmp(s1, s2, strlen(s1)) ...&#xD;
... strncmp(s1, s2, strlen(&lt;font color=&quot;#ff0000&quot;>&#xD;
&lt;i>&#xD;
&lt;b>&#xD;
s2&lt;/b>&lt;/i>&lt;/font>)) ...&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;+0&quot;>strncmp&lt;/font> compara as duas strings e retorna um número inferior a 0 se a primeira, de forma léxica, for menor do que a segunda (viria na frente em um dicionário), 0 se elas fossem iguais e um número superior a 0 se a primeira fosse maior. Entretanto, ela apenas compara a quantidade de caracteres fornecida pelo terceiro argumento. O problema é que o comprimento da primeira string é usado para limitar a comparação, quando deveria ser o comprimento da segunda.&lt;/p>&#xD;
&lt;p>Esta técnica exigiria três testes, um para cada valor de retorno distinto. Aqui estão os três que você poderia usar:&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table     style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;      cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    s1&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    s2&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>resultado esperado&lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>resultado real&lt;/th>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;a&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;bbb&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &amp;lt;0&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &amp;lt;0&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;bbb&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;a&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &amp;gt;0&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &amp;gt;0&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;foo&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;foo&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    =0&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    =0&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>O defeito não foi descoberto porque nada nesta técnica &lt;i>força&lt;/i>, o terceiro argumento a ter qualquer valor. O que é necessário é um caso de teste como este:&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table     style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;      cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    &lt;b>s1&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    &lt;b>s2&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    &lt;b>resultado esperado&lt;/b>&#xD;
                &lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>&#xD;
                    &lt;b>resultado real&lt;/b>&#xD;
                &lt;/th>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;foo&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &quot;foo&lt;font color=&quot;#ff0000&quot;>&lt;i>&lt;b>d&lt;/b>&lt;/i>&lt;/font>&quot;&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &lt;font color=&quot;#ff0000&quot;>&lt;i>&lt;b>&amp;lt;0&lt;/b>&lt;/i>&lt;/font>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    =0&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>Mesmo existindo técnicas adequadas para a captura de tais defeitos, elas raramente são usadas na prática. O seu esforço de teste será provavelmente mais bem empregado em um rico conjunto de testes que visem muitos tipos de defeitos (e que você espere capturar este tipo, como um efeito colateral).&lt;/p>&#xD;
&lt;h4>Resultados indistintos&lt;/h4>&#xD;
&lt;p>Existe um perigo quando você está codificando - e testando – método por método. Aqui está um exemplo. Existem dois métodos. O primeiro, &lt;font size=&quot;+0&quot;>connect&lt;/font>, pretende estabelecer uma conexão de rede:&lt;/p>&#xD;
&lt;blockquote>&#xD;
&#xD;
void connect() {&#xD;
   ...&#xD;
   Integer portNumber = serverPortFromUser();&#xD;
   if (portNumber == null) {&#xD;
      // pop up message about invalid port number&#xD;
      return;&#xD;
   }&#xD;
&#xD;
&lt;/blockquote>&#xD;
&lt;p>Ele chama &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> para obter um número de porta. Este método retorna dois valores distintos. Ele retorna um número de porta escolhido pelo usuário, se o número escolhido for válido (1000 ou superior). Caso contrário, retorna nulo. Se nulo for retornado, o código sob teste mostra uma mensagem de erro e termina.&lt;/p>&#xD;
&lt;p>Quando &lt;font size=&quot;+0&quot;>connect&lt;/font> foi testado, funcionou como o esperado: um número de porta válido fez com que uma conexão fosse estabelecida, e um inválido direcionou para uma mensagem.&lt;/p>&#xD;
&lt;p>O código para &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> é um pouco mais complicado. Primeiro ele mostra uma janela que pede por uma string e tem os botões padrão OK e CANCEL. Com base no que o usuário fizer, existirão quatro casos:&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>Se o usuário digitar um número válido, esse número é retornado.&lt;/li>&#xD;
    &lt;li>Se o número for muito pequeno (menos de 1000), nulo é retornado (de modo que a mensagem sobre número de porta inválido seja exibida).&lt;/li>&#xD;
    &lt;li>Se o número for mal formado, nulo é novamente retornado (e a mesma mensagem é apropriada).&lt;/li>&#xD;
    &lt;li>Se o usuário clicar em CANCEL, nulo é retornado.&lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>Este código também funciona como previsto.&lt;/p>&#xD;
&lt;p>A combinação dos dois pedaços de código, porém, tem uma consequência ruim: o usuário pressiona CANCEL e recebe uma mensagem sobre um número de porta inválido. Todo o código funciona como o esperado, mas o efeito geral ainda está errado. Ele foi testado de forma razoável, mas um defeito foi esquecido.&lt;/p>&#xD;
&lt;p>O problema aqui é que &lt;font size=&quot;+0&quot;>nulo&lt;/font> é um resultado que representa dois &lt;i>significados&lt;/i> distintos (&quot;valor ruim&quot; e &quot;usuário cancelou&quot;). Nada nessa técnica força você a perceber o problema com o design de &lt;font     size=&quot;+0&quot;>serverPortFromUser&lt;/font>.&lt;/p>&#xD;
&lt;p>Entretanto, o teste pode ajudar. Quando &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> é testado em condições de isolamento - só para ver se ele retorna o valor esperado em cada um desses quatro casos - o contexto de uso é perdido. Ao invés, suponha que ele tenha sido testado através de &lt;font size=&quot;+0&quot;>connect&lt;/font>. Existiriam quatro testes que exercitariam ambos os métodos simultaneamente:&lt;/p>&#xD;
&lt;div align=&quot;center&quot;>&#xD;
    &lt;table     style=&quot;BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid&quot;      cellspacing=&quot;0&quot; bordercolordark=&quot;#808080&quot; cellpadding=&quot;4&quot; width=&quot;85%&quot; bordercolorlight=&quot;#808080&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>entrada&lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>resultado esperado&lt;/th>&#xD;
                &lt;th scope=&quot;col&quot; align=&quot;middle&quot; width=&quot;25%&quot; bgcolor=&quot;#c0c0c0&quot;>processo pensado&lt;/th>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>usuário digita &quot;1000&quot;&lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>a conexão para a porta 1000 é aberta&lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> retorna um número, que é usado.&lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td>&#xD;
                    &lt;p align=&quot;center&quot;>o usuário digita &quot;999&quot;&lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td>&#xD;
                    &lt;p align=&quot;center&quot;>mensagem sobre número de porta inválido&lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td>&#xD;
                    &lt;p align=&quot;center&quot;>&#xD;
                        &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> retorna nulo, o que leva a uma mensagem&lt;/p>&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &lt;p align=&quot;center&quot;>usuário digita &quot;i99&quot;&lt;/p>&#xD;
                &lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>mensagem sobre número de porta inválido&lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &lt;font size=&quot;+0&quot;>serverPortFromUser&lt;/font> retorna nulo, o que leva a uma mensagem&lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>o usuário clica em CANCEL&lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>todo processo de conexão deve ser cancelado&lt;/td>&#xD;
                &lt;td align=&quot;middle&quot; width=&quot;25%&quot;>&#xD;
                    &lt;font size=&quot;+0&quot;>&lt;i>serverPortFromUser&lt;/i>&lt;/font>&lt;i> retorna nulo. Ei espere um minuto, isso não faz sentido...&lt;/i>&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>Como normalmente é o caso, a execução de testes em um contexto maior revela problemas de integração que escapam dos testes em pequena escala. E, como também é muitas vezes o caso, uma cuidadosa reflexão durante o design de testes revela o problema antes do teste ser executado. (Mas se o defeito não for previsto, então ele será capturado quando o teste for executado.)&lt;br />&#xD;
    &lt;br />&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
