<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-aJBLg1aguP1bIWvQbJSd6w" name="developer_testing,4.085829182735815E-305" guid="-aJBLg1aguP1bIWvQbJSd6w" changeDate="2006-11-13T19:42:19.105-0300" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_test__developer_testing__concept_of&quot; name=&quot;XE_test__developer_testing__concept_of&quot;>&lt;/a>&lt;a&#xD;
id=&quot;XE_design__developer_testing__concept_of&quot; name=&quot;XE_design__developer_testing__concept_of&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>&lt;/a>Introdução&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    O termo &quot;Teste de Desenvolvedor&quot; é usado para classificar as atividades de testes mais apropriadamente realizadas por&#xD;
    desenvolvedores de software. Isto também Inclui os artefatos criados por essas atividades. Os Testes de Desenvolvedor&#xD;
    englobam o trabalho tradicionalmente elaborado nas seguintes categorias: Teste de Unidade, grande parte dos Testes de&#xD;
    Integração e alguns aspectos do que é normalmente chamado de Testes de Sistema. Apesar dos Testes de Desenvolvedor&#xD;
    estarem tradicionalmente associados com as atividades da disciplina de Implementação, eles também têm uma relação com&#xD;
    as atividades da disciplina de Análise e Design.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Pensando nos Testes de Desenvolvedor desta forma &quot;holística&quot;, você ajudará a atenuar alguns dos riscos associados com&#xD;
    as abordagens mais &quot;atomizadas&quot;, tradicionalmente usadas. Na abordagem tradicional para Testes de Desenvolvedor, o&#xD;
    esforço é inicialmente focado na avaliação de que todas as unidades estejam trabalhando de forma independente.&#xD;
    Posteriormente no ciclo de vida de desenvolvimento, à medida que o trabalho de desenvolvimento se aproxima da&#xD;
    conclusão, as unidades integradas são agrupadas em um sistema ou subsistema executável e testadas desta forma, pela&#xD;
    primeira vez.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Esta abordagem tem uma série de falhas. Em primeiro lugar, porque encoraja uma abordagem em fases para os testes das&#xD;
    unidades integradas e posteriormente os subsistemas, todos os erros identificados durante estes testes são normalmente&#xD;
    encontrados tarde demais. Esta descoberta tardia normalmente resulta na decisão de não tomar nenhuma ação corretiva, ou&#xD;
    na exigência de grande retrabalho para correção. Este retrabalho tanto é caro como susceptível de atrasar o progresso&#xD;
    em outras áreas. Isso aumenta o risco do projeto ser desviado ou abandonado.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Em segundo lugar, quando criamos limites rígidos entre os Testes Unitários, de Integração e de Sistema, aumentamos a&#xD;
    probabilidade de que os erros que estejam no perímetro destes limites não sejam descobertos por ninguém. O risco é&#xD;
    agravado quando a responsabilidade por esses tipos de testes é atribuída a equipes diferentes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O estilo dos testes de desenvolvedor recomendado pelos processos iterativos, encoraja o desenvolvedor a se concentrar&#xD;
    nos testes mais valiosos e adequados a serem conduzidos em determinado momento. Mesmo no escopo de uma única iteração,&#xD;
    geralmente é mais eficiente para o desenvolvedor localizar e corrigir a maioria dos erros no seu próprio código,&#xD;
    evitando a sobrecarga adicional de passar para outro grupo de testes. O resultado desejado é a rápida descoberta dos&#xD;
    erros de software mais importantes - não importando se estes erros estejam na unidade independente, na integração das&#xD;
    unidades ou no funcionamento das unidades integradas em um cenário de usuário final.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;DeveloperTestingPitfalls&quot; name=&quot;DeveloperTestingPitfalls&quot;>&lt;/a>Armadilhas no Início do Uso de Testes de&#xD;
    Desenvolvedor&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Muitos desenvolvedores, que começam a fazer um trabalho substancialmente mais profundo de teste, desistem do esforço&#xD;
    rapidamente. Eles acham que os testes não serão produtivos. Além disso, alguns desenvolvedores que começam bem com os&#xD;
    testes de desenvolvedor, descobrem que criaram uma suíte de teste impossível de manter e que normalmente é abandonada.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Esta página fornece algumas diretrizes para vencer as primeiras barreiras e para a criação de uma suíte de testes que&#xD;
    evite os problemas de manutenção. Para mais informações, consulte Diretrizes: Mantendo Suítes de Testes Automatizados.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Estabeleça expectativas&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Aqueles que acham os testes de desenvolvedor gratificantes irão fazê-los. Aqueles que os veem somente como faina&#xD;
    encontram formas de evitá-los. Trata-se simplesmente na natureza de muitos desenvolvedores na maioria das indústrias, e&#xD;
    tratar isso como uma falta vergonhosa de disciplina não tem sido historicamente bem sucedido. Portanto, como um&#xD;
    desenvolvedor você deve esperar que os testes sejam gratificantes e fazer o que for preciso para torná-los&#xD;
    gratificantes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os testes de desenvolvedor ideais seguem um ciclo edição-teste muito curto. Você faz uma pequena alteração no produto,&#xD;
    tal como adicionar um novo método a uma classe, e então re-executa seus testes imediatamente. Se algum teste não&#xD;
    passar, você saberá exatamente qual código causou a falha. Este ritmo de desenvolvimento fácil e seguro, é a maior&#xD;
    recompensa dos testes de desenvolvedor. Uma longa sessão de depuração deverá ser excepcional.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O fato de ser comum que uma mudança feita em uma classe acarrete erro em outra, implica que você terá que re-executar&#xD;
    não apenas os testes da classe alterada, mas muitos outros. Idealmente, você re-executará a suíte de teste completa&#xD;
    para seu componente muitas vezes por hora. Toda vez que fizer uma alteração significativa, você re-executará a suíte,&#xD;
    observará os resultados e avançará para a próxima alteração ou corrigirá a última alteração. Poderá ser necessário&#xD;
    investir algum esforço para tornar possível esse rápido feedback.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Automatize seus testes&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Se os testes forem manuais, executá-los várias vezes pode não ser muito prático. Para alguns componentes, os testes&#xD;
    automatizados são fáceis. Um exemplo seria uma base de dados em memória. Ela se comunica com seus clientes através de&#xD;
    uma API e não tem nenhuma outra interface com o mundo exterior. Os testes para ela seriam semelhantes a este:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os testes são diferentes do código cliente normal em um único aspecto: ao invés de confiar nos resultados das chamadas&#xD;
    a API, eles os verificam. Se a API tornar mais fácil a escrita do código cliente, também tornará mais fácil a escrita&#xD;
    do código de teste. Se o código de teste &lt;i>não&lt;/i> for fácil de escrever, você já terá um alerta de que a API pode ser&#xD;
    melhorada. O Design Teste-Primeiro é, portanto, coerente com o foco do processo iterativo no cedo tratamento dos riscos&#xD;
    importantes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Quão mais estreitamente ligado ao mundo exterior o componente for, mais difícil será de testá-lo. Existem dois casos&#xD;
    comuns: interfaces gráficas de usuário e componentes de retaguarda.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Interfaces gráficas de usuário&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Suponha que o banco de dados no exemplo acima receba seus dados através de um retorno de chamada ao objeto de interface&#xD;
    de usuário. O retorno de chamada é invocado quando o usuário preenche alguns campos de texto e pressiona um botão.&#xD;
    Testá-lo manualmente preenchendo os campos e pressionando o botão não é algo que você deseje fazer várias vezes&#xD;
    seguidas. Você tem que arranjar uma forma de efetuar a entrada sob controle programático, normalmente &quot;pressionando&quot; o&#xD;
    botão via código.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Pressionar o botão irá fazer com que algum código no componente seja executado. É provável, que o código mude o estado&#xD;
    de alguns objetos da interface de usuário. Sendo assim você também deve arranjar uma maneira de consultar esses objetos&#xD;
    de forma programática.&#xD;
&lt;/p>&#xD;
&lt;h5>&#xD;
    Componentes de retaguarda&#xD;
&lt;/h5>&#xD;
&lt;p>&#xD;
    Suponha que o componente em teste não implemente uma base de dados. Ao invés, é uma emulação de uma base de dados em&#xD;
    disco. O teste em uma base de dados verdadeira poderia ser difícil. Talvez seja difícil de instalar e configurar. As&#xD;
    licenças para isso podem ser caras. A base de dados poderá tornar os testes lentos o bastante para que você não fique&#xD;
    inclinado a executá-los com frequência. Nestes casos, vale a pena substituir a base de dados por um simples componente&#xD;
    que seja suficiente para permitir a execução dos testes.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Essas substituições também são úteis quando o seu componente tem que interagir com outro que ainda não esteja pronto.&#xD;
    Você não quer que o seu teste fique aguardando pelo código de outra pessoa.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Para mais informações, veja Conceitos: Stubs.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Não escreva suas próprias ferramentas&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Os testes de desenvolvedor parecem ser bem simples. Você cria alguns objetos, faz uma chamada através de uma API,&#xD;
    verifica os resultados e anuncia a falha do teste se os resultados não forem os esperados. É também conveniente ter&#xD;
    alguma forma de agrupar os testes, a fim de que eles possam ser executados individualmente ou como suítes completas. As&#xD;
    ferramentas que suportam esses requisitos são chamadas de &lt;i>frameworks de teste&lt;/i>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os testes de desenvolvedor &lt;b>são&lt;/b> simples, e os requisitos para os frameworks de teste não são complicados. Se, no&#xD;
    entanto, você cair na tentação de escrever seu próprio framework de teste, você poderá gastar muito mais tempo com&#xD;
    ajustes no framework do que provavelmente esperava. Existem muitos frameworks de teste disponíveis, tanto comerciais&#xD;
    como de código aberto, e não há nenhuma razão para não usar um deles.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Crie código de suporte&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    O código do teste tende a ser repetitivo. É comum ver sequências de código como esta:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Este código é criado copiando uma verificação, colando-a e então a editando para fazer outra verificação.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O perigo aqui é duplo. Se a interface mudar, muita edição terá que ser feita. (Nos casos mais complexos, uma simples&#xD;
    substituição global, não basta.) Também, se o código for muito complicado, a intenção do teste pode ficar perdida no&#xD;
    texto.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Quando você notar que está se repetindo, considere seriamente a fatoração das repetições em código de suporte. Embora o&#xD;
    código acima seja um mero exemplo, ficará mais legível e manutenível se for escrito assim:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os desenvolvedores escrevem testes muitas vezes errados pelo fato de copiar-e-colar. Se você suspeitar que esteja nesta&#xD;
    tendência, será mais útil errar conscientemente na outra direção. Limpe seu código de todo texto duplicado.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Escreva os testes primeiro&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Escreve os testes após o código é uma faina. A urgência é correr com eles, para terminá-los e seguir em frente.&#xD;
    Escrever os testes antes do código faz parte de um ciclo de feedback positivo. À medida que você implemente mais&#xD;
    código, você verá mais testes passarem até finalmente todos os testes executarem com sucesso. As pessoas que escrevem&#xD;
    os testes primeiro aparentam ser mais bem sucedidas, e isso não requer muito tempo. Para obter mais informações, veja&#xD;
    &lt;a class=&quot;elementLinkWithType&quot; href=&quot;./../../../xp/guidances/concepts/design_teste-primeiro_73AA5ED9.html&quot;&#xD;
    guid=&quot;6.556259235358794E-306&quot;>Concept: Design Teste-Primeiro&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Mantenha os testes compreensíveis&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    É possível que você, ou alguém, tenha que modificar os testes posteriormente. Uma situação típica é que uma iteração&#xD;
    posterior exija uma mudança no comportamento de um componente. Por exemplo, suponha que o componente tenha declarado um&#xD;
    método para raiz quadrada como este:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Nessa versão, um argumento negativo faz com que &lt;font size=&quot;+0&quot;>sqrt&lt;/font> retorne NaN (&quot;não é um número&quot; do &lt;i>Padrão&#xD;
    para Aritmética Binária de Ponto Flutuante&lt;/i> IEEE 754-1985). Na nova iteração, o método para raiz quadrada aceitará&#xD;
    números negativos e retornará um resultado complexo:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os testes anteriores para &lt;font size=&quot;+0&quot;>sqrt&lt;/font> terão que ser alterados. O que significa compreender o que eles&#xD;
    fazem, e atualizá-los para que funcionem com o novo método &lt;font size=&quot;+0&quot;>sqrt&lt;/font>. Ao atualizar os testes, você&#xD;
    deve tomar cuidado para não destruir o seu poder de encontrar erros. Uma forma que às vezes acontece é a seguinte:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Outras formas são mais sutis: os testes foram alterados para que realmente funcionem, mas eles já não testam o que&#xD;
    originalmente teriam que testar. O resultado final, após várias iterações, poderá ser uma suíte de teste muito fraca&#xD;
    que não detecte vários erros. Isto é normalmente chamado de &quot;decadência da suíte de teste&quot;. Uma suíte decadente será&#xD;
    abandonada, porque sua manutenção não é viável.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Você não pode manter um esforço de busca de erros de teste se não estiver claro quais &lt;a&#xD;
    class=&quot;elementLinkWithUserText&quot;&#xD;
    href=&quot;./../../../xp/guidances/concepts/lista_de_ideias_de_teste_9B7EE6E1.html#TestIdeas&quot;&#xD;
    guid=&quot;8.834380241450745E-306&quot;>Ideias de Teste&lt;/a> um teste implementa. O código de teste tende a ser pouco comentado,&#xD;
    mesmo que seja difícil de entender o &quot;porque&quot; que está por trás do código do produto.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A decadência de suítes de teste é menos provável nos testes diretos para &lt;font size=&quot;+0&quot;>sqrt&lt;/font> do que nos&#xD;
    indiretos. Haverá um código que evocará &lt;font size=&quot;+0&quot;>sqrt&lt;/font>. Este código terá testes. Quando &lt;font&#xD;
    size=&quot;+0&quot;>sqrt&lt;/font> for alterada, alguns destes testes irão falhar. A pessoa que alterou &lt;font size=&quot;+0&quot;>sqrt&lt;/font>&#xD;
    provavelmente terá que alterar esses testes. Pelo fato dela estar menos familiarizada com eles, e do seu relacionamento&#xD;
    com a mudança ser menos claro, ela estará mais suscetível a enfraquecê-los no processo de fazê-los passar.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Quando você estiver criando código de suporte para os testes (como descrito acima), tenha cuidado: o código de suporte&#xD;
    deve esclarecer, e não obscurecer, o propósito dos testes que o usam. Uma queixa comum sobre programas orientados a&#xD;
    objeto é que não existe um único lugar onde tudo seja feito. Se você olhar para qualquer método, tudo o que você&#xD;
    descobre é que ele transmite o trabalho para outro lugar. Essa estrutura tem vantagens, mas torna mais difícil aos&#xD;
    novatos a compreensão do código. A menos que eles façam um esforço, suas alterações poderão ser incorretas ou tornar o&#xD;
    código ainda mais complicado e frágil. O mesmo é válido para código de teste, exceto pelo fato de que será ainda menos&#xD;
    provável que os mantenedores tomem o devido cuidado mais tarde. Você deve evitar o problema escrevendo testes&#xD;
    compreensíveis.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Iguale a estrutura do teste com a do produto&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Suponha que uma pessoa tenha herdado o seu componente. Ela precisa mudar uma parte dele. Ela pode querer examinar os&#xD;
    testes antigos para ajudá-la em seu novo design. Ela quer atualizar os testes antigos antes de escrever o código&#xD;
    (design teste-primeiro).&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Todas essas boas intenções serão inúteis, se ela não puder encontrar os testes apropriados. Ela fará a alteração,&#xD;
    verificará as falhas e corrigirá os testes. Isto irá contribuir para a decadência da suíte de teste.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Por essa razão, é importante que a suíte de teste seja bem estruturada, e que a localização dos testes seja previsível&#xD;
    na estrutura do produto. Geralmente, os desenvolvedores organizam os testes em uma hierarquia paralela, com uma classe&#xD;
    de teste para cada classe do produto. Portanto, se alguém estiver alterando uma classe chamada &lt;font&#xD;
    size=&quot;+0&quot;>Registro&lt;/font>, ele saberá que a classe de teste se chamará &lt;font size=&quot;+0&quot;>TestaRegistro&lt;/font>, e saberá&#xD;
    onde o arquivo fonte pode ser encontrado.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Deixe os testes violarem o encapsulamento&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Você pode limitar seus testes para interagir com o seu componente exatamente como o código cliente faz, através da&#xD;
    mesma interface que o código cliente usa. Entretanto, isso tem desvantagens. Suponha que você está testando uma classe&#xD;
    simples que mantém uma lista duplamente encadeada:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;46&quot; alt=&quot;&quot; src=&quot;resources/dvltst-img1.gif&quot; width=&quot;195&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Fig1: Lista duplamente-encadeada&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Em particular, você está testando o método &lt;font size=&quot;+0&quot;>DoublyLinkedList.insertbefore(Objeto existente, Objeto&#xD;
    newObject)&lt;/font>. Em um de seus testes, você pretende inserir um elemento no meio da lista e verificar se ele foi&#xD;
    inserido com sucesso. O teste usa a lista acima para criar esta lista atualizada:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;46&quot; alt=&quot;&quot; src=&quot;resources/dvltst-img2.gif&quot; width=&quot;318&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Fig2: Lista duplamente-encadeada com item inserido&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Ele verifica a exatidão da lista assim:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Isto parece ser suficiente, mas não é. Suponha que a implementação da lista esteja incorreta e que os ponteiros de&#xD;
    retorno não estejam definidos corretamente. Isto é, suponha que a lista atualizada se parece com:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;73&quot; alt=&quot;&quot; src=&quot;resources/dvltst-img3.gif&quot; width=&quot;318&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Fig3: Lista duplamente-encadeada com falha na implementação&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Se &lt;font size=&quot;+0&quot;>DoublyLinkedList.get(int index)&lt;/font> percorrer a lista do início ao fim (provavelmente), o teste&#xD;
    não perceberá esta falha. Se a classe fornecer os métodos &lt;font size=&quot;+0&quot;>elementBefore&lt;/font> e &lt;font&#xD;
    size=&quot;+0&quot;>elementAfter&lt;/font>, a verificação destas falhas será simples:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mas e se ela não fornecer esses métodos? Você pode conceber sequências de chamadas de método mais elaboradas que irão&#xD;
    falhar se o defeito suspeito estiver presente. Por exemplo, isto poderia funcionar:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mas este teste é mais trabalhoso de criar e provavelmente será significativamente mais difícil de manter. (A menos que&#xD;
    você escreva bons comentários, não ficará claro porque o teste está fazendo o que faz). Existem duas soluções:&#xD;
&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>&#xD;
        Adicione os métodos &lt;font size=&quot;+0&quot;>elementBefore&lt;/font> e &lt;font size=&quot;+0&quot;>elementAfter&lt;/font> à interface pública.&#xD;
        Mas que exponha efetivamente a implementação para todos e torne as mudanças futuras mais difíceis.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Permita aos testes &quot;olharem sob a capa&quot; e marque ponteiros diretamente.&#xD;
    &lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>&#xD;
    Esta é geralmente a melhor solução, mesmo que seja para uma simples classe como &lt;font size=&quot;+0&quot;>DoublyLinkedList&lt;/font>&#xD;
    e especialmente para as classes mais complexas que existem em seus produtos.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Normalmente, os testes são colocados no mesmo pacote onde estão as classes que eles verificam. Eles fornecem acesso&#xD;
    amigo ou protegido.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;TestDesignMistakes&quot; name=&quot;TestDesignMistakes&quot;>&lt;/a>Erros Característicos de Design de Teste&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Cada teste exercita um componente e verifica se os resultados estão corretos. O design do teste, as entradas que ele&#xD;
    usa e como verifica se o resultado está correto, podem ser bons para revelar defeitos, ou podem inadvertidamente&#xD;
    ocultá-los. Aqui estão algumas características dos erros no design de testes.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha na especificação dos resultados esperados com antecedência&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Suponha que você está testando um componente que converte XML em HTML. É uma tentação pegar algumas amostras de XML,&#xD;
    executar a conversão e, em seguida, analisar os resultados em um navegador. Se a tela parecer correta, você &quot;abençoa&quot; o&#xD;
    HTML e o salva como o resultado esperado oficial. Depois, um teste compara os resultados reais da conversão com os&#xD;
    resultados esperados.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Esta é uma prática perigosa. Mesmo experientes usuários de computador são levados a acreditar no que o computador faz.&#xD;
    É provável que você ignore erros na apresentação da tela. (Sem mencionar que navegadores são bastante tolerantes a HTML&#xD;
    malformado). Ao tornar esse HTML incorreto o resultado esperado oficial, você garantirá que o teste nunca poderá&#xD;
    encontrar o problema.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    É menos perigoso executar uma verificação-dupla, olhando diretamente para o HTML, mas isso ainda é perigoso. Por causa&#xD;
    da saída complicada, será fácil não perceber os erros. Você encontrará mais defeitos se você escrever manualmente a&#xD;
    saída esperada primeiro.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha na verificação da retaguarda&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Os testes normalmente verificam se aquilo que deveria ter sido mudado foi mudado, mas seus criadores frequentemente se&#xD;
    esquecem de verificar se aquilo que deveria ter sido deixado de lado foi deixado de lado. Por exemplo, suponha que um&#xD;
    programa deva alterar os 100 primeiros registros em um arquivo. É uma boa ideia verificar se o 101&lt;sup>o&lt;/sup> não foi&#xD;
    alterado.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Em teoria, você deveria verificar que tudo na &quot;retaguarda&quot;; todo o sistema de arquivos, toda a memória, tudo que for&#xD;
    acessível pela rede; foi deixado intacto. Na prática, você deve escolher cuidadosamente o que pode verificar. Mas é&#xD;
    importante fazer essa escolha.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha na verificação da persistência&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Só porque o componente lhe disse que uma mudança foi feita, não significa que tenha sido efetivamente executada na base&#xD;
    de dados. Você precisa verificar a base de dados através de outro caminho.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha na adição de variedade&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Um teste pode ser projetado para verificar o efeito de três campos em um registro da base de dados, mas muitos outros&#xD;
    campos devem ser preenchidos para executar o teste. Os Testadores irão normalmente usar os mesmos valores várias vezes&#xD;
    para estes campos &quot;irrelevantes&quot;. Por exemplo, eles sempre usarão o nome da namorada em um campo texto, ou 999 em um&#xD;
    campo numérico.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O problema é que, o que não importa, às vezes é realmente importante. Quantas vezes existem problemas que dependem de&#xD;
    alguma combinação obscura de entradas improváveis. Se você usar sempre as mesmas entradas, você não terá nenhuma chance&#xD;
    de encontrar esses erros. Se você variar as entradas persistentemente, você poderá encontrar os erros. Muitas vezes,&#xD;
    não custa nada utilizar um número diferente de 999 ou usar o nome de outra pessoa. Quando a variação dos valores&#xD;
    utilizados em testes não custar nada e algum benefício potencial for gerado, então varie. (Nota: é desaconselhável a&#xD;
    utilização dos nomes das namoradas antigas se a atual estiver trabalhando com você.)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Aqui está mais um benefício. Uma falha plausível é quando o programa usa o campo &lt;i>X&lt;/i> quando deveria ter usado o&#xD;
    campo &lt;i>Y&lt;/i>. Se ambos os campos contiverem &quot;Alvorada&quot;, a falha não poderá ser detectada.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha pelo não uso de dados realistas&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    É comum a utilização de dados criados para os testes. Normalmente esses dados são simples e irreais. Por exemplo, os&#xD;
    nomes de clientes podem ser &quot;Mickey&quot;, &quot;Snoopy&quot; e &quot;Donald&quot;. Pelo fato destes dados serem diferentes do que os usuários&#xD;
    realmente irão entrar - caracteristicamente curtos - eles poderão esconder defeitos reais que os clientes irão&#xD;
    descobrir. Por exemplo, esses nomes com somente uma palavra não detectarão que o código não pode tratar nomes com&#xD;
    espaços.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    É prudente fazer um pequeno esforço extra para usar dados realistas.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha em notar que o código simplesmente não faz nada&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Suponha que você inicializou um registro na base de dados com zeros, executou um cálculo que resultará em zero e será&#xD;
    armazenado no registro e, em seguida, irá verificar se o registro é zero. O que o seu teste demonstrou? O cálculo pode&#xD;
    simplesmente não ter acontecido. Pode não ter sido armazenado nada, e o teste não irá identificar.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Este exemplo parece pouco provável. Mas esse mesmo erro pode surgir de forma sutil. Por exemplo, você pode escrever um&#xD;
    teste para um complexo programa de instalação. O teste destina-se a verificar que todos os arquivos temporários serão&#xD;
    removidos após uma instalação com sucesso. Mas, por causa das opções do instalador, um determinado arquivo temporário&#xD;
    não foi criado no teste. Certamente, esse é o que o programa se esqueceu de remover.&#xD;
&lt;/p>&#xD;
&lt;h4>&#xD;
    Falha em notar que o código faz a coisa errada&#xD;
&lt;/h4>&#xD;
&lt;p>&#xD;
    Às vezes um programa faz a coisa certa por razões erradas. Como um exemplo trivial, considere o seguinte código:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A expressão lógica está errada, e você escreveu um teste que o faz avaliar incorretamente e escolher o caminho errado.&#xD;
    Infelizmente, por pura coincidência, a variável X tem o valor 2, no teste. Sendo assim o resultado do caminho errado&#xD;
    está acidentalmente correto - o mesmo resultado aconteceria se o caminho correto fosse seguido.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Para cada resultado esperado, você deve perguntar se há uma forma plausível desse resultado ser alcançado pelo motivo&#xD;
    errado. Mesmo sendo muitas vezes impossível de saber, às vezes não é.&#xD;
&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
