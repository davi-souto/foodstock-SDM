<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-3AbfvnHrCOIQS63sEjrOew" name="test-first_design,6.556259235358794E-306" guid="-3AbfvnHrCOIQS63sEjrOew" changeDate="2006-11-13T20:58:35.617-0300" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_test__developer_testing__test-first_design&quot; name=&quot;XE_test__developer_testing__test-first_design&quot;>&lt;/a>&lt;a id=&quot;XE_design__test-first_design&quot; name=&quot;XE_design__test-first_design&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introdução&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>O design de testes é criado utilizando informações de vários artefatos, incluindo os artefatos de design tais como realizações de caso de uso, modelos de design ou interfaces classificadoras. Os testes são executados após os componentes terem sido criados. É normal criar o design dos testes exatamente no momento deles serem executados - logo após os artefatos de design de software terem sido criados. Veja o exemplo da Figura 1 abaixo. Aqui, o design de testes começa um pouco antes do final da implementação. É construído a partir dos resultados do design dos componentes. A seta que liga a Implementação a Execução dos Testes indica que os testes não podem ser executados até que a implementação esteja completa.&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;159&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img1.gif&quot; width=&quot;614&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig1: Tradicionalmente, o Design de Testes é realizado tardiamente no ciclo de vida&lt;/p>&#xD;
&lt;p>Entretanto, isto não precisa ser dessa forma. Embora a execução dos testes tenha que esperar até que o componente seja implementado, o design dos testes pode ser feito mais cedo. Pode ser feito logo após a conclusão do artefato de design. Pode até mesmo ser feito em paralelo com o design do componente, como mostrado aqui:&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;158&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img2.gif&quot; width=&quot;610&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig2: O Design Teste-primeiro mantém o design de teste cronologicamente alinhado com o design de software&lt;/p>&#xD;
&lt;p>A antecipação do esforço de teste feita desta forma é comumente chamada de &quot;design teste-primeiro&quot;. Quais são as suas vantagens?&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>Independente de quão cuidadoso você seja no design do software, você cometerá erros. Você pode esquecer um fato relevante. Ou você poderá ter hábitos particulares de pensamento que lhe dificultem ver algumas alternativas. Ou você poderá apenas estar cansado e esquecer alguma coisa. Ter outras pessoas para revisar os artefatos de design ajuda bastante. Eles podem lembrar-se de fatos que você esqueceu, ou ver o que você não conseguiu. Será melhor se essas pessoas tiverem uma perspectiva diferente da sua; olhando o design de forma diferente eles perceberão coisas que você esqueceu.&lt;br /> &lt;br /> A experiência tem mostrado que a perspectiva de teste é eficaz. É incansavelmente concreta. Durante o design do software, é fácil pensar em um campo em particular tal como &quot;exibição do cargo do cliente atual&quot; e seguir em frente sem realmente pensar sobre isso. Durante o design dos testes, você deverá decidir &lt;i>especificamente&lt;/i> o que esse campo vai exibir quando um cliente, aposentado da Marinha e que obteve legalmente uma patente, insista em ser chamado de &quot;Tenente Morton H. Throckbottle (Apos.), Cel.&quot; O seu cargo é &quot;Tenente&quot; ou &quot;Coronel&quot;?&lt;br /> &lt;br /> Se o design dos testes for adiado até exatamente antes da execução dos testes, como na figura 1, você provavelmente irá desperdiçar dinheiro. Um erro no design do software permanecerá escondido até o design dos testes, quando algum testador disser, &quot;Você sabe, eu conheci este oficial da Marinha...&quot;, criar o teste &quot;Morton&quot; e descobrir o problema. Agora uma implementação parcial ou totalmente completa tem que ser re-escrita e um artefato de design terá que ser atualizado. Seria mais barato descobrir o problema antes do início da implementação.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>Alguns erros podem ser capturados antes do design dos testes. Ao invés disso, eles serão capturados pelo implementador. Isto ainda é ruim. A implementação deverá dar uma parada enquanto o foco muda de como implementar o design para o que o design deveria ser. Isso é perturbador mesmo quando os papéis de Implementador e Designer são executados pela mesma pessoa; Quando são por pessoas diferentes, é muito mais. A prevenção desta perturbação é outra forma que o design teste-primeiro ajuda a melhorar a eficiência.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>O design de testes ajuda os implementadores de outra forma, esclarecendo o design. Se houver uma dúvida na cabeça do implementador sobre o significado do design, o design de teste poderá servir como um exemplo específico do comportamento desejado. Isto levará a uma menor quantidade de erros devido a mal-entendidos do implementador.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>Existirão menos erros mesmo se a questão &lt;i>não passou&lt;/i> pela cabeça do implementador - mas deveria ter passado. Por exemplo, poderia ter tido uma ambiguidade que o Designer tivesse interpretado inconscientemente de uma forma e o implementador de outra. Se o implementador estiver trabalhando, tanto com o design como com as instruções específicas para o componente fazer o que se deseja - a partir dos casos de teste - o componente estará mais susceptível a fazer o que é realmente necessário.&lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Examples&quot; name=&quot;Examples&quot;>Exemplos&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Aqui estão alguns exemplos para lhe dar o sabor do design teste-primeiro.&lt;/p>&#xD;
&lt;p>Suponha que você está criando um sistema destinado a substituir o antigo método &quot;pedir a secretária&quot; para alocação de salas de reunião. Um dos métodos da classe &lt;font size=&quot;+0&quot;>BdReunião&lt;/font> chama-se &lt;font size=&quot;+0&quot;>getReuniao&lt;/font>, e tem a seguinte assinatura:&lt;/p>&#xD;
&lt;p>Dado uma pessoa e uma hora, o método &lt;font size=&quot;+0&quot;>getReuniao&lt;/font> retorna a reunião que está agendada para a pessoa nessa hora. Se a pessoa não estiver agendada para nada, ele retorna o objeto especial &lt;font size=&quot;+0&quot;>Reunião&lt;/font>, &lt;font size=&quot;+0&quot;>não-agendada&lt;/font>. Existem alguns casos de teste simples:&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>A pessoa não está em nenhuma reunião em uma determinada hora. A reunião &lt;font size=&quot;+0&quot;>não-agendada&lt;/font> retornou?&lt;/li>&#xD;
    &lt;li>A pessoa está em uma reunião em uma determinada hora. O método retornou a reunião correta?&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Estes casos de teste não são excitantes, mas eles precisam ser testados eventualmente. Eles também podem ser criados agora, escrevendo o código de teste que algum dia irá ser executado. O código Java para o primeiro teste deve ser semelhante a:&lt;/p>&#xD;
&lt;p>Mas existem outras ideias de teste mais interessantes. Por exemplo, este método procura por um uma coincidência. Sempre que um método faz uma pesquisa é uma boa ideia perguntar o que deve acontecer se a pesquisa encontrar mais de uma coincidência. Neste caso, isto significa perguntar &quot;Uma pessoa pode estar em duas reuniões ao mesmo tempo?&quot; Parece impossível, mas perguntar a secretária sobre esse caso pode revelar algo surpreendente. Verifica-se que alguns executivos estão frequentemente agendados em duas reuniões ao mesmo tempo. Seu papel é entrar em uma reunião, fazer a introdução inicial em um curto período de tempo, e depois ir embora. Um sistema que não atenda a este comportamento não será utilizado, pelo menos em parte.&lt;/p>&#xD;
&lt;p>Este é um exemplo do design teste-primeiro feito no nível de implementação que captura um problema de análise. Existem algumas coisas a serem observadas sobre isso:&lt;/p>&#xD;
&lt;ol>&#xD;
    &lt;li>Espera-se que uma boa especificação de caso de uso e a análise já tivessem descoberto este requisito. Nesse caso, o problema teria sido evitado &quot;antecipadamente&quot; e &lt;font size=&quot;+0&quot;>getReuniao&lt;/font> teria sido projetado de forma diferente. (não poderia retornar uma reunião; deveria retornar um conjunto de reuniões). Porém a análise sempre ignora alguns problemas, e é melhor que eles sejam descobertos durante a implementação do que após a implantação.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>Em muitos casos, os Designers e Implementadores não têm conhecimento suficiente do domínio para capturar tais problemas - eles não terão tempo ou oportunidade de perguntar a secretária. Neste caso, a pessoa responsável pelo design dos testes para o método &lt;font         size=&quot;+0&quot;>getReuniao&lt;/font> perguntaria, &quot;existe algum caso em que duas reuniões devam ser retornadas?&quot;, pensaria por algum tempo e concluiria que não há. O design teste-primeiro não captura todos os problemas, mas o simples fato de fazer o tipo certo de pergunta aumenta a chance de um problema ser encontrado.&lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>Algumas das mesmas técnicas de testes que se aplicam a implementação aplicam-se igualmente a análise. O design teste-primeiro pode também ser feito por analistas, mas isso não é o tema desta página.&lt;/li>&#xD;
&lt;/ol>&#xD;
&lt;p>O segundo dos três exemplos é um modelo de gráfico de estados para um sistema de aquecimento.&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;253&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img3.gif&quot; width=&quot;567&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig3: Gráfico de estados HVAC&lt;/p>&#xD;
&lt;p>Um conjunto de testes poderia percorrer todos os arcos no gráfico de estados. Um teste poderia iniciar com um sistema inativo, injetar um evento Muito Quente(Too Hot), fazer o sistema falhar durante o estado de Resfriamento/Execução(Cooling/Running), resolver a falha, injetar outro evento Muito Quente(Too Hot) e então colocar o sistema de volta no estado inativo. Visto que isto não exercita todos os arcos, mais testes são necessários. Esses tipos de testes procuram por vários tipos de problemas de implementação. Por exemplo, ao percorrer cada arco, eles verificam se a implementação deixou algum de fora. Usando seqüências de eventos que têm caminhos de erro seguidos por caminhos que devem concluir com sucesso, eles verificam se o código de tratamento de erro deixou de limpar resultados parciais que possam afetar a computação posterior. (para obter mais informações sobre testes de gráficos de estados, veja &lt;a class=&quot;elementLinkWithUserText&quot; href=&quot;./../../../xp/guidances/guidelines/test_ideas_for_statechart_and_flow_diagrams_AD59D4ED.html&quot; guid=&quot;1.0347051690476123E-305&quot;>Diretriz: Ideias de Teste para Gráficos de Estados e Diagramas de Atividade&lt;/a>).&lt;/p>&#xD;
&lt;p>O último exemplo usa parte de um modelo de design. Existe uma associação entre um credor e uma fatura, onde um determinado credor pode ter mais de uma fatura pendente.&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;45&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img4.gif&quot; width=&quot;186&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig4: Associação entre as classes Credor e Fatura&lt;/p>&#xD;
&lt;p>Os testes baseados neste modelo poderão exercitar o sistema quando um credor não tiver nenhuma fatura, uma fatura e várias faturas. Um testador também perguntaria se existem situações em que uma fatura necessite ser associada a mais de um credor, ou uma fatura não tenha nenhum credor. (Talvez as pessoas que atualmente executam o processo em papel, o qual será substituído pelo sistema computacional, usem faturas sem credor para manter o controle dos trabalhos pendentes). Se for verdade, este seria outro problema que deveria ter sido capturado na Análise.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;WhoDoesTest-FirstDesign&quot; name=&quot;WhoDoesTest-FirstDesign&quot;>Quem executa o design teste-primeiro?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>O design teste-primeiro pode ser feito pelo autor do design ou por qualquer outra pessoa. É comum que o autor o faça. A vantagem é que reduz a sobrecarga de comunicação. O Designer e o Designer de Testes não têm que explicar as coisas um para o outro. Um Designer de Testes em separado teria que gastar tempo aprendendo o design, ao passo que o Designer original já o conhece. Finalmente, muitas destas perguntas – tal como &quot;o que acontece se o compressor falhar no estado X?&quot; - são naturais de serem feitas durante o design do artefato de software e o design de teste, de modo que você possa também ter a mesma pessoa perguntando somente uma vez e escrevendo as respostas, sob a forma de testes.&lt;/p>&#xD;
&lt;p>Porém, existem desvantagens. A primeira é que os Designers são, de certa forma, cegos para os seus próprios erros. O processo de design de testes irá revelar algumas dessas cegueiras, mas talvez não tanto quanto uma pessoa diferente iria encontrar. O quão problemático isto é, parece variar muito de uma pessoa para outra e está muitas vezes relacionado com a experiência do designer.&lt;/p>&#xD;
&lt;p>Outra desvantagem de ter a mesma pessoa fazendo tanto o design de software como o design de teste é que não há um paralelismo. Considerando que a atribuição de papéis para pessoas diferentes aumentará o esforço total, isso irá provavelmente resultar em menos tempo útil decorrido. Se as pessoas estiverem desesperadas para sair do design e entrar na implementação, investir tempo no design de testes pode ser frustrante. Mais importante, existe uma tendência de dizer que o trabalho já está concluído para poder entrar na outra fase.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;CanAllTestDesignBeDoneAtComponentDesignTime&quot; name=&quot;CanAllTestDesignBeDoneAtComponentDesignTime&quot;>Todo o design de testes pode ser feito ao mesmo tempo em que o design de componentes?&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>Não. A razão é que nem todas as decisões foram tomadas no design. As decisões feitas durante a implementação não estarão bem-testadas pelos testes criados no design. O exemplo clássico desta situação é uma rotina para ordenar vetores. Existem muitos algoritmos de ordenação com diferentes formas de troca. Para grandes vetores, o Quicksort é normalmente mais rápido do que uma ordenação por inserção, mas frequentemente mais lento para pequenos vetores. Sendo assim um algoritmo de ordenação poderá ser implementado usando o Quicksort para vetores com mais de 15 elementos, mas em caso contrário deve ser usada a ordenação por inserção. Esta divisão de trabalho pode ser invisível para os artefatos de design. Você &lt;i>poderia&lt;/i> representá-la em um artefato de design, mas o Designer poderia ter decidido que tornar essas decisões explícitas não seria vantajoso. Uma vez que o tamanho do vetor não interfira no design, o design de teste poderia inadvertidamente usar apenas pequenos vetores, significando que o código do Quicksort não seria testado totalmente.&lt;/p>&#xD;
&lt;p>Como outro exemplo, considere esta parte de um diagrama de sequência. Ela mostra um &lt;font size=&quot;+0&quot;>SecurityManager&lt;/font> chamando o método &lt;font size=&quot;+0&quot;>log()&lt;/font> de &lt;font size=&quot;+0&quot;>StableStore&lt;/font>. Neste caso, porém, o método &lt;font     size=&quot;+0&quot;>log()&lt;/font> retorna um erro, fazendo com que &lt;font size=&quot;+0&quot;>SecurityManager&lt;/font> chame &lt;font     size=&quot;+0&quot;>Connection.close()&lt;/font>.&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;161&quot; alt=&quot;&quot; src=&quot;resources/tstfrsdsg-img5.gif&quot; width=&quot;303&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>Fig5: instância do diagrama de sequência de SecurityManager&lt;/p>&#xD;
&lt;p>Este é um bom lembrete para o Implementador. Sempre que &lt;font size=&quot;+0&quot;>log()&lt;/font> falhar, a conexão deve ser fechada. A questão é se o Implementador realmente fez isso, e se fez corretamente em &lt;i>todos&lt;/i> os casos ou apenas em &lt;i>alguns&lt;/i>. Para responder à pergunta, o Designer de Testes deve encontrar todas as chamadas para &lt;font     size=&quot;+0&quot;>StableStore.log()&lt;/font> e certificar-se que cada um desses pontos de chamada está fornecendo um erro para ser tratado.&lt;/p>&#xD;
&lt;p>Pode parecer estranho executar este tipo de teste, tendo em vista que você apenas verificou os trechos de códigos que chamam &lt;font     size=&quot;+0&quot;>StableStore.log()&lt;/font>. Você não poderia simplesmente verificar se ele trata os erros corretamente?&lt;/p>&#xD;
&lt;p>Talvez a inspeção pudesse ser o suficiente. Mas o código para tratamento de erros é notoriamente propenso a erros, porque muitas vezes depende implicitamente de pressupostos que a existência do erro tenha violado. O exemplo clássico é o código que trata falhas de alocação. Aqui está um exemplo:&lt;/p>&#xD;
&lt;p>Este código tenta recuperar de um erro de falta de memória, pela limpeza (tornando assim a memória disponível) e então continua a processar eventos. Vamos supor que este é um design aceitável. &lt;font size=&quot;+0&quot;>emergencyRestart&lt;/font> toma muito cuidado para não alocar memória. O problema é que &lt;font size=&quot;+0&quot;>emergencyRestart&lt;/font> chama alguma rotina utilitária, que chama outra rotina utilitária, que chama outra rotina utilitária e que aloca um novo objeto. Pelo fato de não existir mais memória, então todo o programa falha. Estes tipos de problemas são difíceis de encontrar através de inspeção.&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Test-FirstDesignAndRUPPhases&quot; name=&quot;Test-FirstDesignAndRUPPhases&quot;>Design teste-primeiro e as fases do Processo&lt;/a> Unificado&lt;/h3>&#xD;
&lt;p>Até este ponto, nós assumimos implicitamente que você poderia fazer a maior quantidade possível de design de testes, o mais rápido possível. Ou seja, você iria derivar todos os testes possíveis a partir dos artefatos de design, acrescentando mais tarde, apenas os testes baseados na implementação. Isto pode não ser adequado na fase de Elaboração, porque tais testes completos podem não estar alinhados com os objetivos de uma iteração.&lt;/p>&#xD;
&lt;p>Suponha que um protótipo arquitetural esteja sendo construído para demonstrar a viabilidade do produto aos investidores. Ele poderá se basear em algumas instâncias dos principais casos de uso. O código deve ser testado para ver se os suporta. Mas existe algum perigo se outros testes forem criados? Por exemplo, poderia ser evidente que o protótipo ignora importantes casos de erro. Porque não documentar a necessidade de tratamento desses erros escrevendo casos de teste que irão exercitá-los?&lt;/p>&#xD;
&lt;p>Mas o que aconteceria se o protótipo fizesse seu trabalho e revelasse que a abordagem arquitetural não funciona? Então, a arquitetura seria jogada fora - juntamente com todos os testes de tratamento de erro. Nesse caso, o esforço de projetar os testes não irá gerar nenhum valor. Teria sido melhor esperar, e apenas projetar os testes necessários para verificar se esse protótipo prova-de-conceito realmente prova o conceito.&lt;/p>&#xD;
&lt;p>Isto pode parecer uma pequena questão, mas existem fortes efeitos psicológicos em jogo. É na fase de Elaboração que são tratados os maiores riscos. Toda a equipe do projeto deve focar estes riscos. Ter pessoas se concentrando em questões menores, desvia o foco e drena a energia da equipe.&lt;/p>&#xD;
&lt;p>Então, onde o design teste-primeiro pode ser usado com sucesso na fase de Elaboração? Ele pode desempenhar um papel importante na exploração adequada dos riscos arquiteturais. A consideração de como a equipe irá saber, precisamente, se um risco tem sido percebido ou evitado, irá adicionar clareza ao processo de design e poderá muito bem resultar em uma melhor construção inicial da arquitetura.&lt;/p>&#xD;
&lt;p>Durante a fase de Construção, os artefatos de design são colocados em sua forma final. Todas as realizações de caso de uso necessárias são implementadas, bem como as interfaces para todas as classes. Pelo fato do objetivo da fase ser exaustivo, é apropriado completar o design teste-primeiro. Eventos posteriores poderão invalidar poucos, ou nenhum teste.&lt;/p>&#xD;
&lt;p>As fases de Concepção e Transição normalmente têm menor foco nas atividades de design para as quais os testes são adequados. Quando forem, o design teste-primeiro é aplicável. Por exemplo, poderia ser usado com o trabalho candidato de prova-de-conceito na Concepção. Assim como nos testes das fases de Construção e Elaboração, ele deve ser alinhado com os objetivos da iteração.&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
