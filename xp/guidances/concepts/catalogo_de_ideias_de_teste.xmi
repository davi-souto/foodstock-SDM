<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-OrjIrRLW6v_XnqLUQ9GYaQ" name="test-ideas_catalog,1.2384224477983028E-305" guid="-OrjIrRLW6v_XnqLUQ9GYaQ" changeDate="2006-12-01T21:08:47.336-0300" version="1.0.0">
  <mainDescription>&lt;a id=&quot;XE_test-ideas_catalog__concept_of&quot; name=&quot;XE_test-ideas_catalog__concept_of&quot;>&lt;/a> &#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;Introduction&quot; name=&quot;Introduction&quot;>Introdução&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Grande parte da programação consiste em usar as coisas que você já usou várias vezes antes e usá-las, mais uma vez, em&#xD;
    um contexto diferente. Essas coisas são normalmente certas estruturas de classes de dados (tais como listas encadeadas,&#xD;
    tabelas hash ou bancos de dados relacionais) ou &lt;i>operações&lt;/i> (tais como pesquisar, ordenar, criar arquivos&#xD;
    temporários ou mostrar uma janela do navegador). Por exemplo, dois bancos de dados relacionais de clientes terão muitas&#xD;
    características em estereotipadas.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A coisa interessante sobre esses estereótipos é que eles têm &lt;i>falhas&lt;/i> estereotipadas. As pessoas não inventam&#xD;
    novas formas imaginativas para inserir incorretamente alguma coisa em uma lista duplamente encadeada. Elas tendem a&#xD;
    cometer os mesmos erros que cometeram anteriormente. Um programador que mostra uma janela do navegador pode cometer um&#xD;
    desses erros estereotipados:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        criar uma nova janela quando uma, que já estava aberta, deveria ser reutilizada&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        deixar de tornar visível uma janela do navegador minimizada ou obscurecida&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        usar o Internet Explorer quando o usuário escolheu outro navegador como padrão&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        não verificar se o JavaScript está ativado&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Uma vez que as falhas são estereotipadas, são as &lt;i>ideias de teste&lt;/i> que podem encontrá-las. Coloque estas ideias de&#xD;
    teste em seu catálogo para que você possa reutilizá-las.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;HowCatalogsFindFaults&quot; name=&quot;HowCatalogsFindFaults&quot;>Como um Catálogo de Ideias de Teste Encontra Falhas&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Uma das virtudes de um catálogo é que uma única ideia de teste pode ser útil para encontrar mais de uma falha oculta.&#xD;
    Veja um exemplo de uma ideia que encontra duas falhas.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A primeira falha aconteceu em um compilador C. Este compilador aceita as opções de linha de comando &quot;-table&quot; ou&#xD;
    &quot;-trace&quot; ou &quot;-nolink&quot;. As opções podem ser abreviadas para as suas menores formas únicas. Por exemplo, &quot;-ta&quot; é o mesmo&#xD;
    que &quot;-table&quot;. Entretanto, &quot;-t&quot; não é permitido, porque é ambíguo: pode significar tanto &quot;-table&quot; como &quot;-trace&quot;.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Internamente, as opções de linha de comando são armazenadas em uma tabela como esta:&#xD;
&lt;/p>&#xD;
&lt;div align=&quot;left&quot;>&#xD;
    &lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; width=&quot;25%&quot; border=&quot;1&quot;>&#xD;
        &lt;tbody>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;100%&quot;>&#xD;
                    -table&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;100%&quot;>&#xD;
                    -trace&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
            &lt;tr>&#xD;
                &lt;td width=&quot;100%&quot;>&#xD;
                    -nolink&#xD;
                &lt;/td>&#xD;
            &lt;/tr>&#xD;
        &lt;/tbody>&#xD;
    &lt;/table>&lt;br />&#xD;
&lt;/div>&#xD;
&lt;p>&#xD;
    Quando uma opção é encontrada na linha de comando, ela é procurada na tabela. Ela tem correspondência se tiver o mesmo&#xD;
    prefixo de qualquer entrada da tabela, isto é, &quot;-t&quot; corresponde a &quot;-table&quot;. Após uma correspondência ter sido&#xD;
    encontrada, o resto da tabela é pesquisado para encontrar outra correspondência. Outra correspondência seria um erro,&#xD;
    porque iria indicar uma ambiguidade.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O código que faz a pesquisa parece com este:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Você vê o problema? É bastante sutil.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O problema está na declaração break. A intenção é parar e sair do laço mais externo quando uma correspondência&#xD;
    duplicada for encontrada, mas ele só sai do laço interno. Isto tem o mesmo efeito de não encontrar uma segunda&#xD;
    correspondência: o índice da primeira correspondência é retornado.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Note que esta falha só pode ser encontrada se a opção for procurada por duas correspondências na tabela, tal como &quot;-t&quot;&#xD;
    iria.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Agora vamos analisar outra falha completamente diferente.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O código obtém uma string. Supõe-se que irá substituir o último '=' na string por um '+'. Se não houver nenhum '=',&#xD;
    nada será feito. O código usa a rotina &lt;font size=&quot;+0&quot;>strchr&lt;/font> da biblioteca C padrão para encontrar a&#xD;
    localização de '='. Aqui está o código:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Este problema também é um tanto sutil.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A função &lt;font size=&quot;+0&quot;>strchr&lt;/font> retorna a &lt;i>primeira&lt;/i> correspondência na string, e não a última. A função&#xD;
    correta é &lt;font size=&quot;+0&quot;>str&lt;b>&lt;u>r&lt;/u>&lt;/b>chr&lt;/font>. O problema é provavelmente um erro tipográfico. (Na verdade, o&#xD;
    problema oculto é que é definitivamente desaconselhável colocar duas funções cujos nomes diferem somente por um&#xD;
    caractere em uma biblioteca padrão.)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Este erro só pode ser encontrado quando houver dois ou mais sinais de igual na entrada. Isto é:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        &quot;a=b&quot; retornaria o resultado correto, &quot;a+b&quot;.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &quot;noequals&quot; iria retornar o resultado correto, &quot;noequals&quot;.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        &quot;a=b=c&quot; iria retornar incorretamente &quot;a+b=c&quot;, e não o correto &quot;a=b+c&quot;&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    O que há de interessante e útil aqui é que temos duas falhas com causas completamente diferentes (erro tipográfico,&#xD;
    equívoco de uma construção C), e as diferentes manifestações no código (chamada à função errada, declaração mal usada&#xD;
    ou incompleta) que podem ser encontradas pela &lt;i>mesma&lt;/i> ideia de teste (busca de algo que ocorre duas vezes).&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;GoodCatalogs&quot; name=&quot;GoodCatalogs&quot;>Um Bom Catálogo de Ideias de Teste&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    O que torna um catálogo bom?&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Conter um pequeno conjunto de ideias de teste que possam encontrar um conjunto muito maior de falhas ocultas.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Seja fácil de ler rapidamente. Permitir que seja possível ignorar as ideias de teste que não são relevantes para a&#xD;
        sua situação.&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Conter somente as ideias de teste que você irá usar. Por exemplo, alguém que nunca irá lidar com navegadores web&#xD;
        não deveria ter que lidar com as ideias de teste para programas que usam navegadores web. Alguém que trabalhe com&#xD;
        software de jogos irá querer um catálogo mais curto do que alguém que trabalhe com software de segurança crítica. A&#xD;
        pessoa dos jogos pode se dar ao luxo de concentrar-se apenas nas ideias de teste que têm maior chance de encontrar&#xD;
        falhas.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Dadas essas regras, parece ser melhor ter mais do que um catálogo. Alguns dados e operações são comuns a todas as&#xD;
    linguagens, sendo assim, as suas ideias de teste podem ser colocadas em um catálogo que todos os programadores possam&#xD;
    usar. Outros são específicos para um determinado domínio, então as ideias de teste para eles podem ser colocadas em um&#xD;
    catálogo de ideias teste de domínio específico.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O catálogo de exemplo (&lt;a href=&quot;./resources/tstids_short-catalog.pdf&quot; target=&quot;_blank&quot;>tstids_short-catalog.pdf&lt;/a>)(&lt;a&#xD;
    href=&quot;http://www.adobe.com/products/acrobat/alternate.html&quot;>Obtenha o Adobe Reader&lt;/a>), usado no exemplo a seguir, é&#xD;
    uma boa opção para começar. Ideias de Teste para Misturas de Es e OUs é outro exemplo.&#xD;
&lt;/p>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;UsingACatalogExample&quot; name=&quot;UsingACatalogExample&quot;>Um Exemplo de Uso de um Catálogo de Ideias de Teste&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Veja aqui como você pode usar o catálogo de exemplo (&lt;a href=&quot;./resources/tstids_short-catalog.pdf&quot;&#xD;
    target=&quot;_blank&quot;>tstids_short-catalog.pdf&lt;/a>)(&lt;a href=&quot;http://www.adobe.com/products/acrobat/alternate.html&quot;>Obtenha o&#xD;
    Acrobat Reader&lt;/a>). Suponha que você esteja implementando este método:&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> tem dois diretórios como argumentos. Quando um arquivo no primeiro diretório&#xD;
    tiver o mesmo nome de um arquivo, no segundo, &lt;font size=&quot;+0&quot;>applytocommonfiles&lt;/font> realiza algumas operações nos&#xD;
    dois arquivos. Ele desce nos subdiretórios.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    O método para usar o catálogo é através da varredura à procura dos segmentos que correspondam a sua situação. Considere&#xD;
    as ideias de teste em cada segmento e veja se elas são pertinentes e, então, escreva aquelas que são relevantes em uma&#xD;
    &lt;a class=&quot;elementLink&quot; href=&quot;./../../../xp/guidances/concepts/lista_de_ideias_de_teste_9B7EE6E1.html&quot;&#xD;
    guid=&quot;8.834380241450745E-306&quot;>Lista de Ideias de Teste&lt;/a>.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;b>Nota:&lt;/b> Esta descrição passo-a-passo pode fazer parecer que o uso do catálogo seja trabalhoso. Leva mais tempo&#xD;
    para ler sobre a criação da lista de verificação do que para realmente criar uma.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Sendo assim, no caso de &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font>, você pode aplicar o catálogo da forma descrita nesta&#xD;
    seção.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A primeira entrada é para &lt;b>Qualquer Objeto&lt;/b>. Qualquer um dos argumentos poderia ser um ponteiro nulo? Esta é uma&#xD;
    questão do contrato entre &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> e seus invocadores. O contrato pode ser tal que os&#xD;
    invocadores não passem um ponteiro nulo. Se eles fizerem isso, você não poderá confiar no comportamento esperado: &lt;font&#xD;
    size=&quot;+0&quot;>applyToCommonFiles&lt;/font> poderia executar qualquer ação. Neste caso, nenhum teste é apropriado, visto que&#xD;
    qualquer coisa que &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> fizer não estará errado. Se, entretanto, for exigido que&#xD;
    &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> verifique se há ponteiros nulos, a ideia de teste seria útil. Vamos assumir a&#xD;
    última, que nos dá esta lista inicial de ideias de teste:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        d1 é nulo (caso de erro)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d2 é nulo (caso de erro)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        op é nulo (caso de erro)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A próxima entrada do catálogo é &lt;b>Strings&lt;/b>. Os nomes dos arquivos são strings, e são comparados para ver se&#xD;
    correspondem. A ideia de testar com a strings vazia (&quot;&quot;) não parece útil. Presumivelmente algumas rotinas padrão de&#xD;
    comparação de string serão usadas, e elas irão tratar as strings vazias corretamente.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Mas espere... Se existem strings sendo comparadas, o que acontece com Maiúsculas e Minúsculas? Suponha que &lt;font&#xD;
    size=&quot;+0&quot;>d1&lt;/font> contenha um arquivo chamado &quot;Arquivo&quot; e &lt;font size=&quot;+0&quot;>d2&lt;/font> contenha um arquivo chamado&#xD;
    &quot;arquivo&quot;. Esses arquivos correspondem? No Unix, certamente que não. No Microsoft&amp;reg; Windows&amp;reg;, eles certamente iriam.&#xD;
    Outra ideia de teste:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Os arquivos correspondem nos dois diretórios, mas a caixa dos nomes é diferente.&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Note que esta ideia de teste não veio diretamente do catálogo. Entretanto, o catálogo chamou a nossa atenção para um&#xD;
    aspecto específico do programa (nomes de arquivos como strings), e a nossa criatividade nos deu uma ideia adicional. É&#xD;
    importante não usar o catálogo restritivamente - use-o como uma técnica para brainstorming, uma forma de inspirar novas&#xD;
    ideias.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A próxima entrada é &lt;b>Coleções&lt;/b>. Um diretório é uma coleção de arquivos. Muitos programas que tratam coleções&#xD;
    falham quando elas estão vazias. Alguns que tratam as coleções vazias, ou com muitos elementos, falham nas coleções com&#xD;
    exatamente um elemento. Então estas ideias são úteis:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        d1 está vazio&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d2 está vazio&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d1 tem somente um arquivo&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d2 tem somente um arquivo&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A próxima ideia é usar uma coleção do tamanho máximo possível. Isto é útil porque programas como &lt;font&#xD;
    size=&quot;+0&quot;>applyToCommonFiles&lt;/font> muitas vezes são testados com poucos diretórios comuns. Então, alguns usuários&#xD;
    usam-nos com duas enormes árvores de diretório com milhares de arquivos em cada uma, apenas para descobrir que o&#xD;
    programa é grotescamente ineficiente com a memória e não pode tratar este caso realista.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Agora, testar o tamanho máximo absoluto para um diretório não é importante, só precisa ser grande o bastante para que&#xD;
    um usuário possa usá-lo. Entretanto, deve existir pelo menos &lt;i>algum&lt;/i> teste com mais de três arquivos em um&#xD;
    diretório:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        d1 contém muitos arquivos&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d2 contém muitos arquivos&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A ideia de teste final (elementos duplicados) não se aplica aos diretórios de arquivos. Isto é, se você tiver um&#xD;
    diretório com dois arquivos que tenham o mesmo nome, você tem um problema independente de &lt;font&#xD;
    size=&quot;+0&quot;>applyToCommonFiles&lt;/font> - o sistema de arquivos está corrompido.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    A próxima entrada do catálogo é &lt;b>Pesquisa&lt;/b>. Essas ideias podem ser traduzidas em termos de &lt;font&#xD;
    size=&quot;+0&quot;>applyToCommonFiles&lt;/font> como estas:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        d1 e d2 não têm arquivos em comum (todos os nomes são diferentes)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d1 e d2 têm exatamente um arquivo em comum (é alfabeticamente o último elemento do diretório)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d1 e d2 têm mais de um arquivo em comum&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    A ideia de teste final verifica se &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> termina muito cedo. Ele retorna assim que&#xD;
    encontra a primeira correspondência? A observação entre parênteses na ideia de teste anterior pressupõe que o programa&#xD;
    irá buscar a lista de arquivos em um diretório usando alguma rotina da biblioteca que os retorne ordenados&#xD;
    alfabeticamente. Se não estiver, será melhor encontrar qual é o último realmente (o criado mais recentemente?) e fazer&#xD;
    com que ele seja o elemento de correspondência. Antes de dedicar muito tempo para descobrir como os arquivos estão&#xD;
    ordenados, pergunte-se se colocar o elemento a ser correspondido por último, irá tornar mais fácil a descoberta de&#xD;
    defeitos. Colocar um elemento na última posição de uma coleção é mais útil se o código manipula a coleção usando um&#xD;
    índice. Se estiver usando um iterator, é extremamente improvável que a ordem tenha importância.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Vamos analisar mais uma entrada no catálogo de exemplo. A entrada &lt;b>Estruturas Ligadas&lt;/b> lembra-nos que estamos&#xD;
    comparando &lt;i>árvores&lt;/i> de diretório, e não apenas coleções de arquivos. Seria triste se &lt;font&#xD;
    size=&quot;+0&quot;>applyToCommonFiles&lt;/font> trabalhasse apenas nos diretórios de nível superior, e não nos de níveis&#xD;
    inferiores. Decidir a forma de testar se &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> trabalha em diretórios de níveis&#xD;
    mais baixos nos obriga a enfrentar a incompletude da sua descrição.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Em primeiro lugar, quando &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> desce nos subdiretórios? Se a estrutura de&#xD;
    diretórios tiver esta aparência&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;162&quot; alt=&quot;&quot; src=&quot;resources/tstidsctl-img1.gif&quot; width=&quot;334&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Figura 1: Estrutura de diretório&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    será que &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> desce até &lt;font size=&quot;+0&quot;>Cdir&lt;/font>? Isso parece não fazer&#xD;
    sentido. Pode não existir correspondência na outra árvore de diretórios. Na verdade, parece que os arquivos nos&#xD;
    subdiretórios só podem corresponder se os nomes dos subdiretórios corresponderem. Ou seja, suponha que temos esta&#xD;
    estrutura de diretório:&#xD;
&lt;/p>&#xD;
&lt;p align=&quot;center&quot;>&#xD;
    &lt;img height=&quot;165&quot; alt=&quot;&quot; src=&quot;resources/tstidsctl-img2.gif&quot; width=&quot;334&quot; />&#xD;
&lt;/p>&#xD;
&lt;p class=&quot;picturetext&quot;>&#xD;
    Figura 2: Uma segunda estrutura de diretório&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Os arquivos chamados &quot;File&quot; não correspondem, porque eles estão em subdiretórios diferentes. Os subdiretórios devem&#xD;
    descender apenas se tiverem o mesmo nome em &lt;font size=&quot;+0&quot;>d1&lt;/font> e &lt;font size=&quot;+0&quot;>d2&lt;/font>. O que leva a estas&#xD;
    ideias de teste:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Algum subdiretório em d1 não é encontrado em d2 (sem descendência).&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Algum subdiretório em d2 não é encontrado em d1 (sem descendência)&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        Algum subdiretório aparece tanto em d1 como em d2 (descende)&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Mas isso levanta outras questões. A operação (&lt;font size=&quot;+0&quot;>op&lt;/font>) pode ser aplicada para encontrar subdiretórios&#xD;
    ou apenas arquivos? Se for aplicada aos subdiretórios, ela deve ser aplicada antes ou depois da descendência? Isso faz&#xD;
    diferença, se, por exemplo, a operação apagar os arquivos ou diretórios correspondentes. E em assim sendo, a operação&#xD;
    &lt;i>deve&lt;/i> ser autorizada a modificar a estrutura de diretórios? e, mais especificamente: qual é o comportamento&#xD;
    correto de &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> se isso acontecer? (este é o mesmo problema que surge com&#xD;
    iteradores.)&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Estes tipos de dúvidas surgem normalmente quando você lê atentamente uma descrição da criação de ideias de teste para o&#xD;
    método. Mas vamos deixá-las de lado por enquanto. Quaisquer que sejam as dúvidas, deverão existir ideias de teste para&#xD;
    elas - ideias de teste que verifiquem se o código as implementa corretamente.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Vamos voltar ao catálogo. Nós ainda não consideramos todas as ideias de teste. A primeira - vazia (nada na estrutura) -&#xD;
    pergunta por um diretório vazio. Nós já obtivemos isso no item &lt;b>Coleções&lt;/b>. Nós também já obtivemos a estrutura&#xD;
    &lt;b>mínima não-vazia&lt;/b>, que é um diretório com um único elemento. Este tipo de redundância não é raro, mas é fácil de&#xD;
    ignorar.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    E a &lt;b>estrutura circular&lt;/b>? As estruturas de diretório não podem ser circulares - um diretório não pode estar dentro&#xD;
    de um de seus descendentes ou dentro de si mesmo... ou pode? E os atalhos (no Windows) ou links simbólicos (no UNIX)?&#xD;
    Se houver um atalho na árvore de diretório em &lt;font size=&quot;+0&quot;>d1&lt;/font> que aponta de volta para &lt;font&#xD;
    size=&quot;+0&quot;>d1&lt;/font>, &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> deve continuar descendo indeterminadamente? A resposta&#xD;
    pode levar a uma ou mais ideias de teste novas:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        d1 é circular por causa de atalhos ou links simbólicos&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        d2 é circular por causa de atalhos ou links simbólicos&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>&#xD;
    Dependendo do comportamento correto, podem existir mais ideias de teste além desta.&#xD;
&lt;/p>&#xD;
&lt;p>&#xD;
    Finalmente, e a &lt;b>profundidade maior que um&lt;/b>? As primeiras ideias de teste irão garantir que estamos testando em um&#xD;
    nível descendente de subdiretório, mas devemos verificar se &lt;font size=&quot;+0&quot;>applyToCommonFiles&lt;/font> continua&#xD;
    descendo:&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        descendo diversos níveis (&amp;gt;1) dos subdiretórios em d1&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        descendo diversos níveis (&amp;gt;1) dos subdiretórios em d2&#xD;
    &lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;h3>&#xD;
    &lt;a id=&quot;CreatingYourOwnCatalogs&quot; name=&quot;CreatingYourOwnCatalogs&quot;>Criando e Mantendo Seu Próprio Catálogo de Ideias de&#xD;
    Teste&lt;/a>&#xD;
&lt;/h3>&#xD;
&lt;p>&#xD;
    Como mencionado anteriormente, os catálogos genéricos não conterão todas as ideias de teste que você precisa. Mas, os&#xD;
    catálogos de &lt;i>domínios&lt;/i> específicos não têm sido publicados fora das empresas que os criaram. Se você os quiser,&#xD;
    precisa construí-los. Eis alguns conselhos.&#xD;
&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>&#xD;
        Não encha o catálogo com especulações sobre quais ideias poderiam ser boas para encontrar falhas. lembre-se que&#xD;
        cada ideia de teste que você coloca no catálogo custa tempo e dinheiro: &#xD;
        &lt;ul>&#xD;
            &lt;li>&#xD;
                Seu tempo para manter o catálogo&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                O tempo de outros programadores para pensar sobre a ideia de teste&#xD;
            &lt;/li>&#xD;
            &lt;li>&#xD;
                Possivelmente, o tempo de outros programadores para implementar um teste&#xD;
            &lt;/li>&#xD;
        &lt;/ul>&lt;br />&#xD;
        Adicione apenas as ideias que têm demonstrado um registro histórico. Você deve ser capaz de identificar, pelo&#xD;
        menos, uma falha real que a ideia de teste tenha capturado. Idealmente, a falha deverá ser aquela que não foi&#xD;
        detectada por outros testes, isto é, uma que foi relatada quando da execução. Uma boa forma para construir&#xD;
        catálogos é navegar no banco de dados de falhas da sua empresa e questionar como cada uma poderia ter sido&#xD;
        detectada mais cedo.&#xD;
    &lt;/li>&#xD;
    &lt;li style=&quot;LIST-STYLE-TYPE: none&quot;>&#xD;
        &lt;br />&#xD;
        &lt;br />&#xD;
    &lt;/li>&#xD;
    &lt;li>&#xD;
        É pouco provável que o trabalho de criar e manter um catálogo de ideias de teste é algo que possa ser feito em seu&#xD;
        tempo livre. Você precisará alocar um tempo especifico para esta tarefa, tal como para qualquer outra importante.&#xD;
        Nós recomendamos que você crie e mantenha o seu Catálogo de Ideias de Teste durante o Detalhe de Fluxo de Trabalho:&#xD;
        Melhorar os Recursos de Teste.&#xD;
    &lt;/li>&#xD;
&lt;/ul></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
